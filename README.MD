# Rameter

[![npm version](https://img.shields.io/npm/v/rameter.svg)](https://www.npmjs.com/package/rameter)

## What is Rameter?

**Rameter** is a NodeJS based HTTP endpoint/API load test/performance test tool inspired by [Jmeter](https://jmeter.apache.org/), [Locust](https://locust.io/), [K6](https://k6.io/).

The name "Rameter" do come from Ram(from AOC) + (J)meter.

## Why do I make Rameter?

- I like the code-driven way of Locust & K6.
- I like the web dashboard UI of Locust
- I like the detail HTML test report generated by Jmeter.
- I like the idea that we can write load test in JS like K6 do, but I want native Javascript library support.

## Why Rameter?

- Use it if you want to write some simple nodeJS script to do load test to your API.
- Use it if you are using Jmeter, and you feel difficult about how to write dynamic logics with the testing endpoints.
- Use it if you are using Locust, but you want to generate pretty HTML test report like Jmeter do.
- Use it if you are using K6, but you want to use NodeJS native libraries, and you do not need the ultra performance of K6.

## Features?

- Write NodeJS code to define multiple user groups & dynamic scenarios.
- Calling HTTP request sampler with Axios wrapper.
- Realtime web dashboard UI during test running.
- Distributed mode.
- Support Jmeter format CSV output, hence you can use Jmeter to generate HTML report.

----

# Table of Contents
1. [Install](#install)
2. [Hello World](#hello-world)
3. [Component Diagram](#component-diagram)
4. [Realtime Dashboard Demo Screen](#realtime-dashboard-demo-screen)
5. [User Models](#user-models)
6. [Calling HTTP request](#calling-http-request)
7. [Samples](#samples)
8. API (To be update)

----

## Install
```
npm i rameter
```

## Hello World
```javascript
import { Rameter, HttpRequestSampler, sleep, UserModelConfig } from "rameter";

const run = async () => {
  const rameter = new Rameter();

  /**
   * up-lifting
   */
  await rameter.runStandalone({
    master: {
      host: "localhost",
      port: 3001,
    }
  });

  /**
   * define global context
   */
  rameter.exportGlobalContext({});

  /**
   * define user groups
   */
  rameter.defineUserGroup("members");

  /**
   * define user test scenario
   */
  rameter.defineUserScenario("hello scenario", async ({ globalContext, nodeContext, userContext, userId }) => {
    try {
      // call an HTTP endpoint
      await HttpRequestSampler.request({
        method: "GET",
        url: `http://localhost:8080/hello`,
      });
    } catch (e) {
      console.error(e);
    } finally {
      await sleep(100); // think time
    }
  });

  await rameter.readyTest();

  /**
   * Trigger the load test
   */
  await rameter.runUntilFinished([
    {
      userModel: UserModelConfig.stepUserForTime({
        maxUsers: 20,
        steps: 10,
        rampUpTime: 10,
        holdTime: 20,
      }),
      userGroups: ["members"],
      scenarios: ["hello scenario"],
    },
  ]);

  /**
   * shutdown
   */
  await rameter.down();
};
run();
```
----

## Component Diagram

![Component Diagram](https://raw.githubusercontent.com/airicyu/rameter/main/images/Rameter%20Components.png)

- **Master**: Serve as controller. It fire commands to worker nodes to run the test. It collect result statistics.

- **Worker Node**: The actual component to run the test. There can be N worker nodes to scale out test client side capacity.

- **Web Dashboard**: Realtime web dashboard to view test statistics.

### Variable Contexts

- **Global Context**: Context variable to share in whole test scope.

- **User Context**: Context variable to share within user scope.

- **Node Context**: Each worker node can load local resources (e.g: large file) and share within the same node scope.

## Realtime Dashboard Demo Screen

![Realtime dashboard](https://raw.githubusercontent.com/airicyu/rameter/main/images/web%20dashboard%20screencap.png)

It dynamically shows:
- Average response time per API over time
- Throughput per API over time
- API successful rate per API over time
- User Group number of users over time

----

## User Models

### stepUserForTime

1. Ramp up M users.
2. Each User would loop the scenario infinitely.
3. After all users are spawned, the test would end after holding for N seconds.

```javascript
await rameter.runUntilFinished([
  {
    userModel: UserModelConfig.stepUserForTime({
      maxUsers: 20,
      rampUpTime: 10,
      steps: 10,
      holdTime: 60,
      delayTime: 0
    }),
    userGroups: ["members"],
    scenarios: ["hello scenario"],
  },
]);
```
#### Options

| Option     | Description                                            | Mandatory? | Default Value |
|------------|--------------------------------------------------------|------------|---------------|
| maxUsers   | The maximum number of users you want to spawn.         | Yes        | -             |
| steps      | The users would be spawn with this number of steps.    | Yes        | -             |
| rampUpTime | The number of seconds to ramp up all users.            | Yes        | -             |
| holdTime   | The number of seconds to hold after all users spawned. | Yes        | -             |
| delayTime  | The number of seconds to wait before the user ramp up. | No         | 0             |

### stepUserLoopN

1. Ramp up M users.
2. Each User would loop the scenario for N times.
3. After all users finished the loops, the test would be ended.

```javascript
await rameter.runUntilFinished([
  {
    userModel: UserModelConfig.stepUserLoopN({
      maxUsers: 20,
      steps: 10,
      rampUpTime: 10,
      runNTimes: 100,
      delayTime: 0
    }),
    userGroups: ["members"],
    scenarios: ["hello scenario"],
  },
]);
``` 

#### Options

| Option     | Description                                            | Mandatory? | Default Value |
|------------|--------------------------------------------------------|------------|---------------|
| maxUsers   | The maximum number of users you want to spawn.         | Yes        | -             |
| steps      | The users would be spawn with this number of steps.    | Yes        | -             |
| rampUpTime | The number of seconds to ramp up all users.            | Yes        | -             |
| runNTimes  | Each user would run the scenario for N times.          | No         | 1             |
| delayTime  | The number of seconds to wait before the user ramp up. | No         | 0             |

### userLoopForTime

1. Spawn M users.
2. Each User would loop the scenario infinitely.
3. After all users finished the loops, the test would be ended.

```javascript
await rameter.runUntilFinished([
  {
    userModel: UserModelConfig.userLoopForTime({
      maxUsers: 20,
      holdTime: 60,
      delayTime: 0
    }),
    userGroups: ["members"],
    scenarios: ["hello scenario"],
  },
]);
```
#### Options

| Option     | Description                                            | Mandatory? | Default Value |
|------------|--------------------------------------------------------|------------|---------------|
| maxUsers   | The maximum number of users you want to spawn.         | Yes        | -             |
| holdTime   | The number of seconds to hold after all users spawned. | Yes        | -             |
| delayTime  | The number of seconds to wait before the user ramp up. | No         | 0             |

### userLoopN

1. Spawn M users.
2. Each User would loop the scenario for N times.
3. After all users finished the loops, the test would be ended.

```javascript
await rameter.runUntilFinished([
  {
    userModel: UserModelConfig.userLoopN({
      maxUsers: 20,
      holdTime: 60,
      delayTime: 0
    }),
    userGroups: ["members"],
    scenarios: ["hello scenario"],
  },
]);
```
#### Options

| Option     | Description                                            | Mandatory? | Default Value |
|------------|--------------------------------------------------------|------------|---------------|
| maxUsers   | The maximum number of users you want to spawn.         | Yes        | -             |
| runNTimes  | Each user would run the scenario for N times.          | No         | 1             |
| delayTime  | The number of seconds to wait before the user ramp up. | No         | 0             |

----

## Calling HTTP request

**TLDR**: The `HttpRequestSampler.request` method is a light wrapper for Axios request client.

```javascript
const response = await HttpRequestSampler.request({
  method: "GET",
  url: `http://localhost:8080/hello`,
});
```

or 

```javascript
const response = await HttpRequestSampler.request({
  label: "hello API",
  method: "GET",
  url: `http://localhost:3000/hello`,
});
```

What the `HttpRequestSampler.request` actually is:

1) Having a optional `label` option to group HTTP APIs. Otherwise we would use {HTTP method + URL path} as the label.
2) Default to config that all HTTP status code interpret as not error.
3) All remaining options are passed to Axios to call the HTTP request.
4) Collect the time taken and success state statistics.
5) Return back the response object for your own usage.

----

## Samples
- [Hello World](https://github.com/airicyu/rameter/tree/main/samples/sample1-hello-world)
- [Global Context](https://github.com/airicyu/rameter/tree/main/samples/sample2-global-context)
- [User Context](https://github.com/airicyu/rameter/tree/main/samples/sample3-user-context)
- [Writing interactive scenario logic](https://github.com/airicyu/rameter/tree/main/samples/sample4-interactive-scenario)
- [Multiple User Groups & Scenarios](https://github.com/airicyu/rameter/tree/main/samples/sample5-multiple-user-groups-and-scenarios)
- [Generate Jmeter Report](https://github.com/airicyu/rameter/tree/main/samples/sample6-generate-jmeter-report)
- [Distributed Mode](https://github.com/airicyu/rameter/tree/main/samples/sample7-distributed-mode)
- [Node Context](https://github.com/airicyu/rameter/tree/main/samples/sample8-node-context)

----

## API

To be update